<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>++namedtuple: Python-style Named Tuples in C++20</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <style>
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 { text-transform: none; }
    </style>

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="++namedtuple: Python-style Named Tuples in C++20">
    <meta name="author" content="Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <section data-markdown="">
          <script type="text/template">

<a href="https://cppcon.org/"><img src="images/cppcon2021.png" style="width: 35%; background:none; border:none; box-shadow:none;" /></a>

---

## ++namedtuple: Python-style Named Tuples in C++20

---

###### [kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

          </script>
          </section>
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">
### Agenda

* #### Motivation
<!-- .element: class="fragment" data-fragment-index="1" -->
* #### Implementation
<!-- .element: class="fragment" data-fragment-index="2" -->
* #### Showcase
<!-- .element: class="fragment" data-fragment-index="2" -->
* #### Summary
<!-- .element: class="fragment" data-fragment-index="5" -->

---

##### <p align="left" style="background-color:darkblue">&nbsp;&nbsp;&nbsp;&nbsp;`darkblue background - something to remember ‚úì`</p>
<!-- .element: class="fragment" data-fragment-index="6" -->

##### <p align="left" style="background-color:green">&nbsp;&nbsp;&nbsp;&nbsp;`green background - achivement unlocked üëç`</p>
<!-- .element: class="fragment" data-fragment-index="7" -->

###### Powered by [Compiler Explorer](https://godbolt.org)
<!-- .element: class="fragment" data-fragment-index="8" -->

==============================================================================

### Motivation

> Python‚Äôs namedtuple was created to improve code readability by providing a way to access values using descriptive field names instead of integer indices, which most of the time don‚Äôt provide any context on what the values are. This feature also makes the code cleaner and more maintainable.

----

#### std::tuple | Issues

```cpp
const auto x = 4;
const auto y = 2;

const auto t = std::tuple{x, y};
```
<!-- .element: class="fragment" -->

```cpp
const auto x = std::get<int>(t); // compilation error!
```
<!-- .element: class="fragment" -->

```cpp
const auto y = std::get<0>(t);   // wrong value!
const auto x = std::get<1>(t);   // wrong value!
```
<!-- .element: class="fragment" -->

```cpp
const auto [y, x] = t;           // wrong values!
```
<!-- .element: class="fragment" -->

----

#### std::tuple | Issues

```cpp
std::get<2>(t);                  // missing SFINAE friendiness!
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t1 = std::tuple(42,  2, 'z');
constexpr auto t2 = std::tuple(42, 'z', 2);
static_assert(8 == sizeof(t1));
static_assert(12 == sizeof(t2)); // oops, not packed!
```
<!-- .element: class="fragment" -->

----

#### std::tuple | Dream

```cpp
constexpr auto t = tuple(x = 42, y = 2);
static_assert(4 == t.x);
static_assert(2 == t.y);
```
<!-- .element: class="fragment" -->

---

```cpp
std::cout << t;
```
<!-- .element: class="fragment" -->

```sh
{x:4,y:2}
```
<!-- .element: class="fragment" -->

----

#### std::tuple | Dream

```cpp
to_json(t);
```
<!-- .element: class="fragment" -->

```json
{
  'x' : 4,
  'y' : 2
}
```
<!-- .element: class="fragment" -->

```cpp
std::vector<decltype(t)> ts{t};

db.query("SELECT x, y FROM points", ts);
```
<!-- .element: class="fragment" -->

```sh
id,x,y
 0,4,2
```
<!-- .element: class="fragment" -->

----

#### std::tuple | Dream

```cpp
static_assert(requires { t.x; });
static_assert(requires { t.y; });
static_assert(not requires { t.z; });
```
<!-- .element: class="fragment" -->

```cpp
constexpr auto t1 = tuple(x = 42, y = 2,   z = 'z');
constexpr auto t2 = tuple(x = 42, z = 'z', y = 2);
static_assert(8 == sizeof(t1));
static_assert(8 == sizeof(t2));
```
<!-- .element: class="fragment" -->

----

#### std::tuple | Dream

```cpp
constexpr auto t = tuple(x, y);
t.x = 4;
t.y = 2;
static_assert(4 == t.x);
static_assert(2 == t.y);
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t2 = tuple(t, z = 10);
static_assert(4 == t.x);
static_assert(2 == t.y);
static_assert(10 == t.z);
```
<!-- .element: class="fragment" -->

----

### The Goal

---

> To make `++namedtuple` dream come true!
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
constexpr auto t = namedtuple{"x"_t = 4, "y"_t = 2};
```
<!-- .element: class="fragment" -->

```cpp
static_assert(4 == t["x"_t]);
static_assert(2 == t["y"_t]);
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
std::cout << t;
```

<!-- .element: class="fragment" -->

```sh
{x:4,y:2}
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t = namedtuple<"Point">{"x"_t = 4, "y"_t = 2};
std::cout << t;
```

<!-- .element: class="fragment" -->

```sh
Point{x:4,y:2}
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
to_json(t);
```
<!-- .element: class="fragment" -->

```json
{
  'Point' : {
    'x' : 4,
    'y' : 2
  }
}
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
std::get<0>(t);  // still works but issues remain!
std::get<1>(t);  // still works but issues remain!
```
<!-- .element: class="fragment" -->

```cpp
auto [x, y] = t; // still works but issues remain!
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
constexpr auto t = namedtuple("x"_t, "y"_t);
t["x"_t] = 4;
t["y"_t] = 2;
static_assert(4 == t["x"_t]);
static_assert(2 == t["y"_t]);
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t2 = namedtuple(t, "z"_t = 10);
static_assert(4 == t["x"_t]);
static_assert(2 == t["y"_t);
static_assert(10 == t["z"_t]);
```
<!-- .element: class="fragment" -->

----

#### The Goal vs the Reality

```cpp
static_assert(not [](auto tuple) {
   return requires { t["z"_t];}(tuple) // SFINAE friendly!
);
```
<!-- .element: class="fragment" -->

---

```cpp
constexpr auto t1 = namedtuple("x"_t = 42, "y"_t = 2,   "z"_t = 'z');
constexpr auto t2 = namedtuple("x"_t = 42, "z"_t = 'z', "y"_t = 2);
static_assert(8 == sizeof(t1));
static_assert(8 == sizeof(t2));
```
<!-- .element: class="fragment" -->

==============================================================================

### Implementation*

> \* Simplified (~100 LOC) / C++20
<!-- .element: class="fragment" -->

----

```cpp
constexpr auto nt = namedtuple();
static_assert(1u == sizeof(nt));
```
<!-- .element: class="fragment" -->

```cpp
template<class... Ts>
using namedtuple = std::tuple<Ts...>;
```
<!-- .element: class="fragment" -->

----

```cpp
static_assert("name"sv == "name"_t);
static_assert(not std::is_same_v<decltype("x"_t), decltype("y"_t)>);
```
<!-- .element: class="fragment" -->

```cpp
template <auto Name>
constexpr auto operator""_t();
```
<!-- .element: class="fragment" -->

```sh
error: template parameter list for literal operator must be 'char...'
```
<!-- .element: class="fragment" -->

----

#### Class Types in Non-Type Template Parameters - [http://wg21.link/p0732]

<img src="images/udl.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

----

```cpp
static_assert(""sv     == fixed_string(""));
static_assert("name"sv == fixed_string("name"));
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template <auto Size>
struct fixed_string {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  char data[Size + 1]{};
  static constexpr auto size = Size;

  constexpr explicit(false) fixed_string(char const* str) {
    std::copy_n(str, Size + 1, data);
  }
  constexpr explicit(false) operator std::string_view() const {
    return {data, Size};
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template <auto Size>
fixed_string(char const (&)[Size]) -> fixed_string<Size - 1>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

```cpp
template <fixed_string Name>
constexpr auto operator""_t() { return Name; }
```
<!-- .element: class="fragment" -->

```cpp
static_assert("name"sv == "name"_t);
static_assert(not std::is_same_v<decltype("x"_t), decltype("y"_t)>);
```
<!-- .element: class="fragment" -->

----

```cpp
constexpr auto arg = ("name"_t = 42);
static_assert("name"sv == arg.name);
static_assert(42 == arg.value);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template<fixed_string Name, class TValue>
struct arg {
  static constexpr auto name = Name;
  TValue value{};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  template<class T>
  [[nodiscard]] constexpr auto operator=(const T& value) const {
    return arg<Name, T>{.value = value}; // rebind
  }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
template <fixed_string Name>
constexpr auto operator""_t() {
  return arg<Name, std::any>{};
};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

```cpp
constexpr auto nt = namedtuple("x"_t = 42, "y"_t = 100);
static_assert(42 == nt["x"_t]);
static_assert(100 == nt["y"_t]);
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template <class... Ts>
struct namedtuple : Ts... { // since all Ts... will be unique
  constexpr explicit(true) namedtuple(Ts... ts) : Ts{ts}... {}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  template <class T> constexpr auto& operator[](const T&); // modification
  template <class T> constexpr const auto& operator[](const T&) const; // access
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
};
template <class... Ts>
namedtuple(Ts...) -> namedtuple<Ts...>;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

```cpp
template<class... Ts> struct inherit : Ts... {};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
static_assert(
  std::is_same_v<void,
    map_lookup<inherit<arg<"x", int>>, "z", void>
  >);

static_assert(
  std::is_same_v<arg<"x", int>,
    map_lookup<inherit<arg<"x", int>>, "x", void>
  >);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
template <class TDefault, fixed_string>
auto map_lookup(...) -> TDefault; // not found

template <class, fixed_string TKey class TValue>
auto map_lookup(arg<TKey, TValue>*) -> arg<TKey, TValue>; // found
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
template <class T, fixed_string TKey, class TDefault>
using map_lookup = decltype(
  detail::map_lookup<TDefault, TKey, T>(static_cast<T*>(nullptr))
);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

Consider using `boost::mp11::mp_map_find` when dealing only with types

#### Universal Template Parameters - [http://wg21.link/p1985]

----

```cpp
template <class T,
  class TArg = map_lookup<namedtuple, T::name, void>>
    requires(not std::is_void_v<TArg>) {
[[nodiscard]] constexpr const auto& operator[](const T) const {
  return static_cast<const TArg&>(*this).value;
}
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
constexpr auto nt = namedtuple("x"_t = 42, "y"_t = 100);
static_assert(42 == nt["x"_t]);
static_assert(100 == nt["y"_t]);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### Achievement Unlocked

### üëç

<!-- .slide: data-background="green" -->

----

#### Free features

```cpp
constexpr auto nt1 = namedtuple("z"_t = 1'000);
constexpr auto nt2 = namedtuple("x"_t = 42,
                                "y"_t = 100, nt1); // composition
static_assert(42    == nt["x"_t]);
static_assert(100   == nt["y"_t]);
static_assert(1'000 == nt["z"_t]);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
constexpr auto nt1 = namedtuple("z"_t = 1'000);
constexpr auto nt2 = namedtuple("x"_t = 42,
                                "y"_t = 100,
                                "nested"_t = nt1); // nesting
static_assert(42    == nt["x"_t]);
static_assert(100   == nt["y"_t]);
static_assert(1'000 == nt[nested"_t]["z"_t]);
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
static_assert(not [](auto tuple) {
   return requires { ["x"_t];}(tuple) // false -> SFINAE friendly
)(nt1);

static_assert([](auto tuple) {
   return requires { ["z"_t];}(tuple) // true -> SFINAE friendly
)(nt1);
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

```cpp
constexpr auto [x, y] = namedtuple("x"_t = 4, "y"_t = 2);
static_assert(4 == x);
static_assert(2 == y);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```sh
error: cannot decompose class type 'nt::namedtuple<...>'
```
<!-- .element: class="fragment" data-fragment-index="2" -->


----

```cpp
namespace std {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
template <class... Ts>
struct tuple_size<namedtuple<Ts...>>
    : std::integral_constant<std::size_t, sizeof...(Ts)> {};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
template <std::size_t N, class... Ts>
struct tuple_element<N, namedtuple<Ts...>> {
  using type =
    decltype(std::declval<namedtuple<Ts...>>().template get<N>());
};
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}  // namespace std
```
<!-- .element: class="fragment" data-fragment-index="0" -->


----

```cpp
template<class... Ts>
struct namedtuple : Ts... {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  template <std::size_t N> auto& get() {
    using id_type_t = dectype(
      []<auto... Ns>(std::index_sequence<Ns...>) {
        return inherit<arg<Ns, Ts>...>{};
      }
      (std::make_index_sequence<sizeof...(Ts)>{})
    );

    return static_cast<typename 
      map_lookup<decltype(id_type), N, void>())::value_type&
    >(*this).value;
  }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

```cpp
static_assert(4 == nt.get<0>());
static_assert(2 == nt.get<1>());
```
<!-- .element: class="fragment" data-fragment-index="0" -->

---

```cpp
constexpr auto [x, y] = namedtuple("x"_t = 4, "y"_t = 2);
static_assert(4 == x); // ok
static_assert(2 == y); // ok
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

```cpp
constexpr auto nt = namedtuple<"Point">("x"_t = 4, "y"_t = 2);
std::cout << t;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```sh
error: no match for 'operator<<'
```
<!-- .element: class="fragment" data-fragment-index="2" -->

----

```cpp
template<fixed_string Name, class... Ts>
struct namedtuple : Ts... {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  friend std::ostream&
  operator<<(std::ostream& os, const namedtuple& nt) {
    os << std::string_view{Name} << '{';
    [&]<auto... Ns>(std::index_sequence<Ns...>) {
      ((os << (Ns ? "," : "")
           << std::string_view{Ts::name} << ':'
           << static_cast<
                const map_lookup<namedtuple, Ts::name, void>&
              >(nt).value),
       ...);
    }
    (std::make_index_sequence<sizeof...(Ts)>{});
    os << '}';
    return os;
  }
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

----

```cpp
constexpr auto nt = namedtuple<"Point">("x"_t = 4, "y"_t = 2);
std::cout << t;
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```sh
Point{x:4,y:2}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----


```cpp
constexpr auto t1 = namedtuple("x"_t = 42, "y"_t = 2,   "z"_t = 'z');
constexpr auto t2 = namedtuple("x"_t = 42, "z"_t = 'z', "y"_t = 2);
static_assert(8 == sizeof(t1));
static_assert(8 == sizeof(t2));
```
<!-- .element: class="fragment" -->

packed - exercisie for the reader

tip - boost::mp11::mp_sort

----

#### Concepts / C++20 / [C++draft/concepts](http://eel.is/c++draft/concepts)

---

* #### Type constraints (act like documentation for interfaces)
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### Better error messages (Point Of Instantiation - POI)
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### Faster compilation times (In comparison to Substitution Failure is Not an Error - SFINAE)
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
template<class T>
concept Auto = true; // the least constraint concept (same as auto)
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

#### Design By Introspection - https://d.godbolt.org/z/n8e4de

```cpp
constexpr auto foo(auto v) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  if constexpr (requires{ v.foo; }) {
    return v.foo;
  } else {
    return 0;
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
constexpr struct { int foo{42}; } f;
static_assert(42 == foo(f));
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
constexpr struct { int bar{42}; } b;
static_assert(0 == foo(b));
```
<!-- .element: class="fragment" data-fragment-index="5" -->

---

##### Andrei Alexandrescu - https://www.youtube.com/watch?v=HdzwvY8Mo-w
<!-- .element: class="fragment" data-fragment-index="6" -->

<!-- .slide: data-background="darkblue" -->

----


----

#### User Defined Literals (`UDL`) - [C++draft/over.literal](http://eel.is/c++draft/over.literal)

<img src="images/over.literal.png" style="width: 100%; background:none; border:none; box-shadow:none;" />

---

```cpp
constexpr auto operator""_i(int) -> int;
```
<!-- .element: class="fragment" -->

<pre> -> <font color="salmon">error: invalid literal operator parameter type 'int',
      did you mean 'unsigned long long'?</font></pre>
<!-- .element: class="fragment" -->

<!-- .slide: data-background="darkblue" -->

----

#### ut::""_i - User Defined Literals (`UDL`) - https://godbolt.org/z/cZsSK3

```cpp
template <char... Cs>
[[nodiscard]] constexpr auto operator""_i() { // int
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return []<auto... Ns>(std::index_sequence<Ns...>) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    return std::integral_constant<int,
      ((std::pow(10, sizeof...(Ns) - Ns - 1)) * (Cs - '0')) + ...)
    >{};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  }(std::make_index_sequence<sizeof...(Cs)>{});
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
static_assert(0_i  == 0);
static_assert(42_i == 42);
```
<!-- .element: class="fragment" -->

----

#### Immediately-Invoked Function Expression (`IIFE`) - https://godbolt.org/z/aM58T1

```cpp
template<auto N>
constexpr auto unroll = [](auto expr) {
  [expr]<auto ...Is>(std::index_sequence<Is...>) {
    ((expr(), void(Is)), ...);
  }(std::make_index_sequence<N>{});
};
```
<!-- .element: class="fragment" -->

```cpp
int main() {
  unroll<2>([]{ std::puts("C++Now 2021!"); });
}
```
<!-- .element: class="fragment" -->

---

```cpp
.LC0: .string "C++Now 2021!"
main:
  sub     rsp, 8
  mov     edi, OFFSET FLAT:.LC0
  call    puts
  mov     edi, OFFSET FLAT:.LC0
  call    puts
  xor     eax, eax
  add     rsp, 8
  ret
```
<!-- .element: class="fragment" -->

<!-- .slide: data-background="darkblue" -->

----

C++ 20 feature
design by introspection

----

#### Full implementation at:

* #### https://godbolt.org/z/753d8M6Wx
<!-- .element: class="fragment" -->

==============================================================================

### Showcase

```cpp
constexpr auto attendee = namedtuple<"Attendee">("name"_t, "age"_t, "title"_t);
```
<!-- .element: class="fragment" -->

```cpp
std::vector<decltype(employee)> employees{};
employees.emplace_back("John", 24, "Software Engineer");
employees.emplace_back("Mike", 36, "Senior Software Engineer");
```
<!-- .element: class="fragment" -->

```cpp
to_json(employees);
```
<!-- .element: class="fragment" -->

```json
{
  [
    "Employee" : {
      "name"  : "John",
      "age"   : 24,
      "title" : "Software Engineer"
    },
    "Employee" : {
      "name"  : "Mike",
      "age"   : 36,
      "title" : "Senior Software Engineer"
    }
  ]
}
```
<!-- .element: class="fragment" -->

```cpp
constexpr auto employee = namedtuple<"Employee">(employee, "department"_t);
employee
```
<!-- .element: class="fragment" -->


==============================================================================

### Summary

* #### Python-style namedtuple's are powerful and flexible
<!-- .element: class="fragment" -->

* #### C++20 simplifies template meta-programming
<!-- .element: class="fragment" -->

* #### C++ is paying the cost in complexity by lacking reflection capabilities
<!-- .element: class="fragment" -->

==============================================================================

<img src="images/pythonic_cpp.png" style="width: 35%; background:none; border:none; box-shadow:none;" />

---

Let's `name(d)` all `tuple(s)`!

---

#### https://www.quantlab.com/careers
<!-- .slide: data-background-color="white" style="color:black" -->

          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      function handleClick(e) {
        if (1 >= outerHeight - innerHeight) {
          document.querySelector( '.reveal' ).style.cursor = 'none';
        } else {
          document.querySelector( '.reveal' ).style.cursor = '';
        }

        e.preventDefault();
        if(e.button === 0) Reveal.next();
        if(e.button === 2) Reveal.prev();
      }
    </script>

  </body>
</html>
